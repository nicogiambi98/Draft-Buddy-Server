<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Draft Buddy – Public View</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; background:#121212; color:#e6e6e6; }
    header { padding: 12px 16px; background: #0a5a3f; color: #fff; }
    main { padding: 16px; max-width: 1000px; margin: 0 auto; }
    .card { border: 1px solid #2a2a2a; border-radius: 10px; padding: 12px; margin: 12px 0; background: #1a1a1a; box-shadow: 0 2px 6px #0006; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; }
    .row > * { flex: 1 1 320px; }
    table { border-collapse: collapse; width: 100%; }
    .table-wrap { width: 100%; overflow-x: auto; }
    .card table { font-size: 14px; }
    th, td { border: 1px solid #333; padding: 8px 10px; text-align: left; white-space: nowrap; vertical-align: middle; }
    th { background: #222; }
    .muted { opacity: .75; }
    .error { color: #ff6b6b; }
    .ok { color: #27d17f; }
    code { background: #0008; padding: 0 4px; border-radius: 4px; }
    a.btn { display: inline-block; padding: 6px 10px; border-radius: 6px; background: #0b6; color: #fff; text-decoration: none; }
    .pill { font-size: 12px; padding: 2px 6px; border-radius: 999px; background: #ffffff1a; }
    .bingo { display: flex; gap: 16px; align-items: stretch; flex-wrap: wrap; }
    .bingo-sidebar { flex: 0 0 280px; max-width: 100%; }
    .bingo-players { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; max-height: 280px; overflow: auto; padding-right: 4px; }
    .bingo-players .btn { background: #222; color: #eee; border: 1px solid #444; border-radius: 10px; padding: 10px 12px; cursor: pointer; box-shadow: 0 1px 2px #0006; }
    .bingo-players .btn:hover { background: #2a2a2a; }
    .bingo-players .btn.sel { background: #0b6; color: #fff; border-color: #0b6; }
    .bingo-grid { display: grid; grid-template-columns: repeat(3, minmax(64px, 1fr)); gap: 8px; }
    .bingo-cell { border: 1px solid #333; border-radius: 10px; padding: 12px; text-align: center; min-width: 64px; min-height: 64px; display: flex; align-items: center; justify-content: center; flex-direction: column; background:#1b1b1b; }
    .bingo-cell .bingo-lab { font-size: 12px; opacity: .9; margin-bottom: 6px; color:#ddd; line-height: 1.15; word-break: break-word; }
    .bingo-cell.checked { background: rgba(0,187,102,0.15); border-color: #0b6; }
    .bingo-cell.win { box-shadow: inset 0 0 0 2px #0b6; }
    @media (max-width: 700px){
      .bingo { flex-direction: column; }
      .bingo-sidebar { order: 2; }
      .card table { font-size: 12px; }
      th, td { padding: 6px 8px; }
    }
  </style>
  <script>
    // Manager id is injected by the backend by replacing __MANAGER_ID__ placeholder
    const MANAGER_ID = '__MANAGER_ID__';
    const BASE = location.origin;
    const SNAPSHOT_URL = `${BASE}/public/${MANAGER_ID}/snapshot.sqlite`;
    const VERSION_URL = `${BASE}/public/${MANAGER_ID}/version`;

    async function fetchText(url) {
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
      return await r.text();
    }
    async function fetchArrayBuffer(url) {
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
      return await r.arrayBuffer();
    }

    async function load() {
      const statusEl = document.getElementById('status');
      const versionEl = document.getElementById('version');
      const tablesEl = document.getElementById('tables');
      const summaryEl = document.getElementById('summary');

      try {
        const v = await fetchText(VERSION_URL);
        versionEl.textContent = v === '0' ? 'not available yet' : new Date(parseInt(v,10)*1000).toLocaleString();
      } catch (e) {
        versionEl.textContent = 'unknown';
      }

      let SQL;
      try {
        // Load sql.js from CDN (no server changes needed)
        const mod = await window.initSqlJs({ locateFile: f => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${f}` });
        SQL = mod;
      } catch (e) {
        statusEl.innerHTML = `<span class="error">Failed to load sql.js</span>`;
        console.error(e);
        return;
      }

      let dbBytes;
      try {
        dbBytes = new Uint8Array(await fetchArrayBuffer(SNAPSHOT_URL));
      } catch (e) {
        statusEl.innerHTML = `<span class="error">No snapshot available for <b>${MANAGER_ID}</b>. Ask your manager to upload from the app.</span>`;
        console.warn(e);
        return;
      }

      statusEl.innerHTML = `<span class="ok">Snapshot loaded (${(dbBytes.byteLength/1024).toFixed(1)} KB)</span>`;

      const db = new SQL.Database(dbBytes);

      // List tables
      const res = db.exec("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name");
      const tableNames = res.length ? res[0].values.flat() : [];
      if (tablesEl) tablesEl.innerHTML = tableNames.map(n => `<span class="pill">${n}</span>`).join(' ');

      // Dashboard sections
      try { renderActiveEventSection(db, tableNames); } catch (e) { console.warn(e); }
      try { renderPairingsSection(db, tableNames); } catch (e) { console.warn(e); }
      try { renderBingoSection(db, tableNames); } catch (e) { console.warn(e); }
      try { renderLeagueSection(db, tableNames); } catch (e) { console.warn(e); }

      // Populate generic table browser (hidden on public view)
      const selector = document.getElementById('tableSelector');
      if (selector) {
        for (const n of tableNames) {
          const opt = document.createElement('option');
          opt.value = n; opt.textContent = n; selector.appendChild(opt);
        }
        selector.addEventListener('change', () => showTable(db, selector.value));
        if (tableNames.length) showTable(db, tableNames[0]);
      }
    }

    function renderQuery(db, title, sql) {
      let rows = [];
      let columns = [];
      try {
        const r = db.exec(sql);
        if (r.length) {
          columns = r[0].columns;
          rows = r[0].values;
        }
      } catch (e) {
        console.warn('Query failed', e);
      }
      if (!columns.length) return '';
      const head = `<tr>${columns.map(c=>`<th>${escapeHtml(c)}</th>`).join('')}</tr>`;
      const body = rows.map(row => `<tr>${row.map(v => `<td>${escapeHtml(String(v))}</td>`).join('')}</tr>`).join('');
      return `<div class="card"><h3>${title}</h3><div class="table-wrap"><table>${head}${body}</table></div></div>`;
    }

    function showTable(db, name) {
      const out = document.getElementById('tableOut');
      out.innerHTML = renderQuery(db, `Table: ${name}`, `SELECT * FROM '${name}' LIMIT 500`);
    }

    function escapeHtml(s) { return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }

    function getSingle(db, sql) {
      try {
        const r = db.exec(sql);
        if (r.length && r[0].values.length) {
          const cols = r[0].columns;
          const vals = r[0].values[0];
          const obj = {};
          cols.forEach((c, i) => obj[c] = vals[i]);
          return obj;
        }
      } catch (e) { /* noop */ }
      return null;
    }

    function renderActiveEventSection(db, tableNames) {
      const el = document.getElementById('activeEvent');
      if (!tableNames.includes('events')) {
        el.innerHTML = '<p class="muted">No events table.</p>';
        return;
      }
      // Prefer explicit active status, otherwise most recent with current_round>0, otherwise latest
      let ev = getSingle(db, "SELECT id,name,type,rounds,current_round,status,round_start_ts FROM events WHERE status IN ('active','running') ORDER BY id DESC LIMIT 1");
      if (!ev) ev = getSingle(db, "SELECT id,name,type,rounds,current_round,status,round_start_ts FROM events WHERE IFNULL(current_round,0)>0 ORDER BY id DESC LIMIT 1");
      if (!ev) ev = getSingle(db, "SELECT id,name,type,rounds,current_round,status,round_start_ts FROM events ORDER BY id DESC LIMIT 1");
      if (!ev) {
        el.innerHTML = '<p class="muted">No events yet.</p>';
        return;
      }
      const when = ev.round_start_ts ? new Date(parseInt(ev.round_start_ts,10)*1000).toLocaleString() : '—';
      el.innerHTML = `
        <div><b>${escapeHtml(ev.name || 'Event')}</b> <span class="pill">${escapeHtml(ev.type||'')}</span></div>
        <div>Status: <b>${escapeHtml(ev.status||'unknown')}</b></div>
        <div>Round: <b>${ev.current_round ?? 0}</b> / ${ev.rounds ?? '?'}</div>
        <div>Round started: <span class="pill">${when}</span></div>
      `;
      // Cache active id for pairings/scoreboard
      window.__ACTIVE_EVENT_ID__ = ev.id;
      window.__ACTIVE_ROUND__ = ev.current_round ?? 0;
      window.__ACTIVE_EVENT_STATUS__ = (ev.status || '').toLowerCase();
    }

    function renderPairingsSection(db, tableNames) {
      const el = document.getElementById('pairings');
      if (!tableNames.includes('matches')) {
        el.innerHTML = '<p class="muted">No matches table.</p>';
        return;
      }
      const evId = window.__ACTIVE_EVENT_ID__;
      const rnd = window.__ACTIVE_ROUND__;
      const status = (window.__ACTIVE_EVENT_STATUS__ || '').toLowerCase();
      const isClosed = ['closed','finished','ended','complete','completed'].includes(status);
      if (!evId) {
        el.innerHTML = '<p class="muted">No event selected.</p>';
        return;
      }
      if (isClosed) {
        // Render standings using the same logic and tiebreakers as the app (pairing.compute_standings)
        const standings = computeStandings(db, evId);
        if (!standings.length) {
          el.innerHTML = '<p class="muted">No results available.</p>';
          return;
        }
        const head = `<tr><th>#</th><th>Name</th><th>MP</th><th>W-L-D</th><th>OMW%</th><th>GW%</th><th>OGW%</th></tr>`;
        const body = standings.map((st, idx) => {
          const rank = idx + 1;
          const name = st.name;
          const mp = st.mp;
          const wld = `${st.wins}-${st.losses}-${st.draws}`;
          const omwp = (st.omwp || 0).toFixed(2);
          const gwp = (st.gwp || 0).toFixed(2);
          const ogwp = (st.ogwp || 0).toFixed(2);
          const cells = [rank, name, mp, wld, omwp, gwp, ogwp]
            .map(x => `<td>${escapeHtml(String(x))}</td>`).join('');
          return `<tr>${cells}</tr>`;
        }).join('');
        el.innerHTML = `<div class="card"><h3>Final Standings</h3><div class="table-wrap"><table>${head}${body}</table></div></div>`;
        return;
      }
      // Otherwise, show current round pairings
      if (!rnd) {
        el.innerHTML = '<p class="muted">No active round.</p>';
        return;
      }
      const sql = `
        SELECT m.round,
               COALESCE(p1.nickname, p1.name, ep1.guest_name) AS p1name,
               COALESCE(p2.nickname, p2.name, ep2.guest_name) AS p2name,
               m.player1, m.player2,
               m.score_p1 AS s1,
               m.score_p2 AS s2,
               m.bye,
               ep1.id AS ep1_id,
               ep2.id AS ep2_id
        FROM matches m
        LEFT JOIN event_players ep1 ON ep1.id = m.player1
        LEFT JOIN event_players ep2 ON ep2.id = m.player2
        LEFT JOIN players p1 ON p1.id = ep1.player_id
        LEFT JOIN players p2 ON p2.id = ep2.player_id
        WHERE m.event_id = ${evId} AND m.round = ${rnd}
        ORDER BY m.id
      `;
      const r = db.exec(sql);
      if (!r.length || !r[0].values.length) {
        el.innerHTML = '<p class="muted">No pairings for current round.</p>';
        return;
      }
      const rows = r[0].values.map(v => {
        const p1name = v[1];
        const p2name = v[2];
        const s1 = v[5] != null ? v[5] : '';
        const s2 = v[6] != null ? v[6] : '';
        const bye = v[7] ? 1 : 0;
        const ep1id = v[8];
        const ep2id = v[9];
        let p1 = p1name || '';
        let p2 = p2name || '';
        if (bye) {
          if ((ep1id == null || ep1id === undefined) && (ep2id != null)) { p1 = 'BYE'; }
          else if ((ep2id == null || ep2id === undefined) && (ep1id != null)) { p2 = 'BYE'; }
          else { p1 = p1 || 'BYE'; p2 = p2 || 'BYE'; }
        }
        return [p1 || '—', s1, '-', p2 || '—', s2];
      });
      const head = `<tr><th>Player 1</th><th>Score</th><th></th><th>Player 2</th><th>Score</th></tr>`;
      const body = rows.map(row => `<tr>${row.map(x => `<td>${escapeHtml(String(x))}</td>`).join('')}</tr>`).join('');
      el.innerHTML = `<div class="table-wrap"><table>${head}${body}</table></div>`;
    }

    function renderBingoSection(db, tableNames) {
      const el = document.getElementById('bingo');
      if (!tableNames.includes('bingo_players')) {
        el.innerHTML = '<p class="muted">Bingo not configured.</p>';
        return;
      }
      const meta = tableNames.includes('bingo_meta') ? getSingle(db, 'SELECT row0,row1,row2,col0,col1,col2,diag0,diag1,full, win_row0,win_row1,win_row2,win_col0,win_col1,win_col2,win_diag0,win_diag1,win_full FROM bingo_meta WHERE id=1') : null;
      const q = `
        SELECT bp.player_id,
               COALESCE(p.nickname, p.name, 'Player') AS name,
               bp.c0,bp.c1,bp.c2,bp.c3,bp.c4,bp.c5,bp.c6,bp.c7,bp.c8
        FROM bingo_players bp
        INNER JOIN players p ON p.id = bp.player_id
        ORDER BY name ASC
      `;
      const r = db.exec(q);
      const cols = (r.length && r[0].columns) ? r[0].columns : [];
      const allPlayers = (r.length && r[0].values.length) ? r[0].values.map(row => ({
        id: row[0],
        name: row[1],
        cells: row.slice(2, 11).map(x => !!x)
      })) : [];
      // Only show players once they have at least one completed achievement
      const players = allPlayers.filter(p => p.cells.some(Boolean));
      // Build UI containers
      el.innerHTML = `
        ${meta ? renderBingoMeta(meta, players) : ''}
        <div class="bingo">
          <div style="flex:1; min-width:240px;">
            <div id="bingoGrid" class="bingo-grid"></div>
            <div id="bingoLines" class="muted" style="margin-top:6px"></div>
          </div>
          <div class="bingo-sidebar">
            <div id="bingoPlayers" class="bingo-players"></div>
          </div>
        </div>
      `;
      const listEl = document.getElementById('bingoPlayers');
      const gridEl = document.getElementById('bingoGrid');
      const linesEl = document.getElementById('bingoLines');
      // Load labels from DB if present; prefer DB only (no remote JSON fallback)
      let labels = ['1','2','3','4','5','6','7','8','9'];
      try {
        // Be schema-agnostic: inspect table columns first
        const ti = db.exec("PRAGMA table_info(bingo_achievements)");
        if (ti.length && ti[0].values.length) {
          const colNames = ti[0].values.map(r => String(r[1]));
          const idCands = ['id','idx','index','slot','position','pos','num','number'];
          const labCands = ['title','name','label','text','description','achievement','ach','ach_text','value'];
          const idCols = idCands.filter(n => colNames.includes(n));
          let labelCols = labCands.filter(n => colNames.includes(n));
          if (!labelCols.length) {
            // Fall back to any non-id columns
            labelCols = colNames.filter(n => !idCands.includes(n) && !['cid','pk','rowid'].includes(n));
          }
          const orderCol = idCols.length ? idCols[0] : null;
          const lr = db.exec(`SELECT * FROM bingo_achievements ${orderCol ? `ORDER BY ${orderCol} ASC` : ''}`);
          if (lr.length && lr[0].values.length) {
            const tmp = new Array(9);
            let fallbackIdx = 0;
            const colIndex = {};
            lr[0].columns.forEach((n,i)=>{ colIndex[n] = i; });
            for (const row of lr[0].values) {
              // Pick label
              let lab = null;
              for (const cn of labelCols) {
                const i = colIndex[cn];
                if (i == null) continue;
                const v = row[i];
                if (v != null && String(v).trim().length > 0) { lab = String(v); break; }
              }
              if (!lab) continue;
              // Determine slot/index
              let slot = NaN;
              for (const cn of idCols) {
                const i = colIndex[cn];
                if (i == null) continue;
                const v = Number(row[i]);
                if (Number.isFinite(v)) { slot = v; break; }
              }
              if (!Number.isNaN(slot)) {
                if (slot >= 1 && slot <= 9) slot = slot - 1; // normalize 1..9 -> 0..8
              }
              if (Number.isNaN(slot) || slot < 0 || slot > 8) {
                while (fallbackIdx < 9 && tmp[fallbackIdx] != null) fallbackIdx++;
                if (fallbackIdx < 9) tmp[fallbackIdx] = lab;
              } else {
                tmp[slot] = lab;
              }
            }
            for (let i = 0; i < 9; i++) { if (tmp[i]) labels[i] = tmp[i]; }
          }
        }
      } catch(e) { /* ignore */ }
      let selected = players.length ? players[0] : null;
      function renderPlayerList() {
        listEl.innerHTML = players.map(p => `<button class="btn${(selected && p.id===selected.id)?' sel':''}" data-id="${p.id}">${escapeHtml(p.name)}</button>`).join(' ');
        for (const btn of listEl.querySelectorAll('button')) {
          btn.addEventListener('click', () => {
            const id = parseInt(btn.getAttribute('data-id'), 10);
            selected = players.find(x => x.id === id) || selected;
            renderPlayerList();
            renderGrid();
          });
        }
      }
      function renderGrid() {
        const cells = selected ? selected.cells : new Array(9).fill(false);
        const lines = [ [0,1,2], [3,4,5], [6,7,8], [0,3,6], [1,4,7], [2,5,8], [0,4,8], [2,4,6] ];
        const completeIdx = lines.map((idx, i) => idx.every(j => cells[j]) ? i : -1).filter(i => i >= 0);
        gridEl.innerHTML = labels.map((lab, i) => {
          const checked = cells[i];
          const inWin = completeIdx.some(ci => lines[ci].includes(i));
          return `<div class="bingo-cell${checked?' checked':''}${inWin?' win':''}"><div class="bingo-lab">${escapeHtml(String(lab))}</div></div>`;
        }).join('');
        const lineNames = ['Row 1','Row 2','Row 3','Col 1','Col 2','Col 3','Diag ↘','Diag ↙'];
        linesEl.textContent = completeIdx.length ? `Completed: ${completeIdx.map(i=>lineNames[i]).join(', ')}` : 'No complete lines yet.';
      }
      renderPlayerList();
      renderGrid();
    }

    function renderBingoMeta(meta, players){
      const winnerLabel = (pid) => {
        if (pid == null) return '';
        const p = players.find(x => x.id === pid);
        return p ? p.name : `Player ${pid}`;
      };
      const chunks = [];
      if (meta.row0) chunks.push(`<span class="pill">Row 1${meta.win_row0?': '+winnerLabel(meta.win_row0):''}</span>`);
      if (meta.row1) chunks.push(`<span class="pill">Row 2${meta.win_row1?': '+winnerLabel(meta.win_row1):''}</span>`);
      if (meta.row2) chunks.push(`<span class="pill">Row 3${meta.win_row2?': '+winnerLabel(meta.win_row2):''}</span>`);
      if (meta.col0) chunks.push(`<span class="pill">Col 1${meta.win_col0?': '+winnerLabel(meta.win_col0):''}</span>`);
      if (meta.col1) chunks.push(`<span class="pill">Col 2${meta.win_col1?': '+winnerLabel(meta.win_col1):''}</span>`);
      if (meta.col2) chunks.push(`<span class="pill">Col 3${meta.win_col2?': '+winnerLabel(meta.win_col2):''}</span>`);
      if (meta.diag0) chunks.push(`<span class="pill">Diag ↘${meta.win_diag0?': '+winnerLabel(meta.win_diag0):''}</span>`);
      if (meta.diag1) chunks.push(`<span class="pill">Diag ↙${meta.win_diag1?': '+winnerLabel(meta.win_diag1):''}</span>`);
      if (meta.full) chunks.push(`<span class="pill">Full Bingo${meta.win_full?': '+winnerLabel(meta.win_full):''}</span>`);
      if (!chunks.length) return '';
      return `<div style="margin-bottom:6px">${chunks.join(' ')}</div>`;
    }

    function renderLeagueSection(db, tableNames) {
      const el = document.getElementById('league');
      if (!tableNames.includes('leagues')) {
        el.innerHTML = '<p class="muted">No leagues defined.</p>';
        return;
      }
      // Choose active league if available, else most recent by id
      let lg = null;
      try {
        lg = getSingle(db, "SELECT id,name,start_ts,end_ts FROM leagues WHERE end_ts IS NULL ORDER BY id DESC LIMIT 1")
            || getSingle(db, "SELECT id,name,start_ts,end_ts FROM leagues ORDER BY id DESC LIMIT 1");
      } catch (_) {}
      if (!lg) { el.innerHTML = '<p class="muted">No leagues found.</p>'; return; }

      // Mirror app logic (LeagueScreen._compute_league_rows)
      // 1) Select closed events whose round_start_ts falls within league window
      if (!tableNames.includes('events')) { el.innerHTML = '<p class="muted">No events data for league.</p>'; return; }
      const safe_start = (lg.start_ts != null ? parseInt(lg.start_ts, 10) : Math.floor(Date.now()/1000));
      const params = [safe_start];
      let where = "status='closed' AND round_start_ts IS NOT NULL AND round_start_ts >= ?";
      if (lg.end_ts != null) { where += " AND round_start_ts <= ?"; params.push(parseInt(lg.end_ts,10)); }
      let evRows = [];
      try {
        const q = `SELECT id FROM events WHERE ${where}`;
        const stmt = db.prepare(q);
        stmt.bind(params);
        while (stmt.step()) { const row = stmt.getAsObject(); evRows.push(row); }
        stmt.free();
      } catch (e) {
        // Fallback: simple exec without bind (interpolate numbers)
        const q = `SELECT id FROM events WHERE status='closed' AND round_start_ts IS NOT NULL AND round_start_ts >= ${safe_start}` +
                  (lg.end_ts != null ? ` AND round_start_ts <= ${parseInt(lg.end_ts,10)}` : '');
        const r = db.exec(q);
        if (r.length && r[0].values.length) {
          evRows = r[0].values.map(v => ({ id: v[0] }));
        }
      }
      const eventIds = evRows.map(r => r.id).filter(x => x != null);
      if (!eventIds.length) { el.innerHTML = '<p class="muted">No eligible events in this league.</p>'; return; }

      // 2) Build ep_map and participants
      const epMap = {}; // ev_id -> { ep_id: partKey }
      const participants = new Set();
      const qmarks = eventIds.map(()=>'?').join(',');
      try {
        const stmt = db.prepare(`SELECT id, event_id, player_id, guest_name FROM event_players WHERE event_id IN (${qmarks})`);
        stmt.bind(eventIds);
        while (stmt.step()) {
          const row = stmt.getAsObject();
          let key = null;
          if (row.player_id != null) key = parseInt(row.player_id,10);
          else if (row.guest_name) key = `g:${row.guest_name}`;
          if (key == null) continue;
          if (!epMap[row.event_id]) epMap[row.event_id] = {};
          epMap[row.event_id][row.id] = key;
          participants.add(key);
        }
        stmt.free();
      } catch (e) {
        // fallback path
      }
      if (participants.size === 0) { el.innerHTML = '<p class="muted">No participants for this league.</p>'; return; }

      // 3) Resolve names
      const stats = {};
      participants.forEach(key => { stats[key] = { pid: key, name: '', matches: 0, wins: 0, losses: 0, draws: 0 }; });
      const regIds = Array.from(participants).filter(k => typeof k === 'number' && Number.isFinite(k));
      if (regIds.length) {
        const r = db.exec(`SELECT id, COALESCE(nickname, name) AS nm FROM players WHERE id IN (${regIds.join(',')})`);
        if (r.length && r[0].values.length) {
          r[0].values.forEach(v => { const pid = v[0]; const nm = v[1]; if (stats[pid]) stats[pid].name = nm; });
        }
      }
      Array.from(participants).forEach(key => { if (typeof key === 'string' && key.startsWith('g:')) stats[key].name = key.slice(2) || 'Guest'; });

      // 4) Walk matches and accumulate
      for (const evId of eventIds) {
        const r = db.exec(`SELECT player1, player2, score_p1, score_p2, bye FROM matches WHERE event_id = ${evId}`);
        if (!(r.length && r[0].values.length)) continue;
        for (const m of r[0].values) {
          const p1 = m[0], p2 = m[1];
          const s1 = Number(m[2] ?? 0), s2 = Number(m[3] ?? 0);
          const bye = Number(m[4] ?? 0);
          if (bye === 1) {
            const pid1 = epMap[evId] && epMap[evId][p1];
            if (pid1 != null && stats[pid1]) { stats[pid1].wins += 1; stats[pid1].matches += 1; }
            continue;
          }
          const pid1 = epMap[evId] && epMap[evId][p1];
          const pid2 = epMap[evId] && epMap[evId][p2];
          if (pid1 == null || pid2 == null) continue;
          stats[pid1].matches += 1; stats[pid2].matches += 1;
          if (s1 > s2) { stats[pid1].wins += 1; stats[pid2].losses += 1; }
          else if (s2 > s1) { stats[pid2].wins += 1; stats[pid1].losses += 1; }
          else { stats[pid1].draws += 1; stats[pid2].draws += 1; }
        }
      }

      // 5) Compute winrate and league score (same as app)
      const k = 0.3;
      const rows = Object.values(stats).map(st => {
        const mp = st.matches;
        const wr = mp > 0 ? ((st.wins + 0.5 * st.draws) / mp) : 0.0;
        const score = 100.0 * wr * (1.0 - Math.E ** (-k * mp));
        return { ...st, winrate: wr, score };
      });
      rows.sort((a,b) => (b.score - a.score) || (b.winrate - a.winrate) || ((a.name||'').localeCompare(b.name||'')) );

      // 6) Render like the app: #, Name, MP, W-L-D, Winrate %, League Score
      const title = `${escapeHtml(lg.name || 'League')} ${lg.start_ts ? '('+new Date(lg.start_ts*1000).toLocaleDateString()+ (lg.end_ts? ' – '+new Date(lg.end_ts*1000).toLocaleDateString():'') +')' : ''}`;
      if (!rows.length) { el.innerHTML = `<div class="muted">No match data for ${title}.</div>`; return; }
      const head = `<tr><th>#</th><th>Name</th><th>MP</th><th>W-L-D</th><th>Winrate %</th><th>League Score</th></tr>`;
      const body = rows.map((st, idx) => {
        const wld = `${st.wins}-${st.losses}-${st.draws}`;
        const wr = (st.winrate * 100).toFixed(2);
        const ls = st.score.toFixed(2);
        const cells = [idx+1, st.name || 'Player', st.matches, wld, wr, ls].map(x=>`<td>${escapeHtml(String(x))}</td>`).join('');
        return `<tr>${cells}</tr>`;
      }).join('');
      el.innerHTML = `<div style="margin-bottom:6px"><b>${title}</b></div><div class="table-wrap"><table>${head}${body}</table></div>`;
    }

    // Compute standings using app logic (pairing.compute_standings)
function computeStandings(db, eventId) {
  // Load event participants with player names/nicknames
  const nr = db.exec(`SELECT ep.id, p.name, p.nickname, ep.guest_name FROM event_players ep LEFT JOIN players p ON p.id = ep.player_id WHERE ep.event_id = ${eventId} ORDER BY ep.seating_pos`);
  if (!nr.length || !nr[0].values.length) return [];
  const rows = nr[0].values;
  const stats = {};
  const nameMap = {};
  for (const row of rows) {
    const eid = row[0];
    const full = row[1] || '';
    const nick = row[2];
    const guest = row[3];
    let disp;
    if (guest) disp = guest;
    else if (full) {
      disp = (full.length >= 20 && nick) ? nick : full;
    } else disp = 'Unknown';
    nameMap[eid] = disp;
    stats[eid] = { eid, name: disp, mp: 0, wins: 0, losses: 0, draws: 0, matches: 0, game_wins: 0, game_losses: 0, opponents: [] };
  }
  // Process matches
  const mr = db.exec(`SELECT player1, player2, score_p1, score_p2, bye FROM matches WHERE event_id = ${eventId}`);
  if (mr.length && mr[0].values.length) {
    for (const m of mr[0].values) {
      const p1 = m[0];
      const p2 = m[1];
      const s1 = Number(m[2] ?? 0);
      const s2 = Number(m[3] ?? 0);
      const bye = Number(m[4] ?? 0);
      if (bye === 1 && stats[p1]) {
        const st = stats[p1];
        st.wins += 1; st.mp += 3; st.matches += 1; st.game_wins += 2; st.game_losses += 0;
        continue;
      }
      if (stats[p1] && stats[p2]) {
        stats[p1].opponents.push(p2);
        stats[p2].opponents.push(p1);
        stats[p1].game_wins += s1;
        stats[p1].game_losses += s2;
        stats[p2].game_wins += s2;
        stats[p2].game_losses += s1;
        if (s1 > s2) { stats[p1].wins += 1; stats[p1].mp += 3; stats[p2].losses += 1; }
        else if (s2 > s1) { stats[p2].wins += 1; stats[p2].mp += 3; stats[p1].losses += 1; }
        else { stats[p1].draws += 1; stats[p2].draws += 1; stats[p1].mp += 1; stats[p2].mp += 1; }
        stats[p1].matches += 1; stats[p2].matches += 1;
      }
    }
  }
  const floor33 = x => Math.max(x, 0.33);
  // MW% and GW%
  for (const eid in stats) {
    const st = stats[eid];
    const mw = st.matches > 0 ? (st.wins + 0.5 * st.draws) / st.matches : 0.0;
    const gwDen = st.game_wins + st.game_losses;
    const gw = gwDen > 0 ? (st.game_wins / gwDen) : 0.0;
    st.mwp = Math.round(mw * 10000) / 10000;
    st.gwp = Math.round(floor33(gw) * 10000) / 10000;
  }
  // OMW% and OGW%
  for (const eid in stats) {
    const st = stats[eid];
    const opps = st.opponents;
    if (!opps.length) {
      st.omwp = 0.0; st.ogwp = 0.0;
    } else {
      const omwList = opps.map(opp => floor33((stats[opp] && stats[opp].mwp) || 0.0));
      const ogwList = opps.map(opp => floor33((stats[opp] && stats[opp].gwp) || 0.0));
      const omw = omwList.reduce((a,b)=>a+b,0) / omwList.length;
      const ogw = ogwList.reduce((a,b)=>a+b,0) / ogwList.length;
      st.omwp = Math.round(omw * 10000) / 10000;
      st.ogwp = Math.round(ogw * 10000) / 10000;
    }
  }
  // Sort
  const out = Object.values(stats);
  out.sort((a,b)=>{
    if (b.mp !== a.mp) return b.mp - a.mp;
    if (b.omwp !== a.omwp) return b.omwp - a.omwp;
    if (b.gwp !== a.gwp) return b.gwp - a.gwp;
    if (b.ogwp !== a.ogwp) return b.ogwp - a.ogwp;
    return ('' + a.name).localeCompare('' + b.name);
  });
  return out;
}

window.addEventListener('DOMContentLoaded', load);
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js" referrerpolicy="no-referrer"></script>
</head>
<body>
  <header>
    <h2 style="margin:0">Draft Buddy – Public View <small class="muted">(<span id="managerId">__MANAGER_ID__</span>)</small></h2>
  </header>
  <main>
    <div class="row">
      <div class="card">
        <b>Snapshot version:</b> <span id="version" class="pill">checking…</span>
      </div>
    </div>

    <div class="card">
      <div id="status" class="muted">Loading…</div>
    </div>

    <div id="summary"></div>

    <div class="card" id="activeEventCard">
      <h3>Active Event</h3>
      <div id="activeEvent"></div>
    </div>

    <div class="card" id="pairingsCard">
      <h3>Current Round Pairings</h3>
      <div id="pairings"></div>
    </div>

    <div class="card" id="bingoCard">
      <h3>Bingo Progress</h3>
      <div id="bingo"></div>
    </div>

    <div class="card" id="leagueCard">
      <h3>League Standings</h3>
      <div id="league"></div>
    </div>

  </main>
</body>
</html>

