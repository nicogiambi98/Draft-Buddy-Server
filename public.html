<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Draft Buddy – Public View</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; }
    header { padding: 12px 16px; background: #0b6; color: #fff; }
    main { padding: 16px; max-width: 1000px; margin: 0 auto; }
    .card { border: 1px solid #8883; border-radius: 8px; padding: 12px; margin: 12px 0; background: #fff; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; }
    .row > * { flex: 1 1 320px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 6px 8px; text-align: left; }
    th { background: #f5f5f5; }
    .muted { opacity: .7; }
    .error { color: #b00020; }
    .ok { color: #0a0; }
    code { background: #0001; padding: 0 4px; border-radius: 4px; }
    a.btn { display: inline-block; padding: 6px 10px; border-radius: 6px; background: #0b6; color: #fff; text-decoration: none; }
    .pill { font-size: 12px; padding: 2px 6px; border-radius: 999px; background: #0002; }
  </style>
  <script>
    // Manager id is injected by the backend by replacing __MANAGER_ID__ placeholder
    const MANAGER_ID = '__MANAGER_ID__';
    const BASE = location.origin;
    const SNAPSHOT_URL = `${BASE}/public/${MANAGER_ID}/snapshot.sqlite`;
    const VERSION_URL = `${BASE}/public/${MANAGER_ID}/version`;

    async function fetchText(url) {
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
      return await r.text();
    }
    async function fetchArrayBuffer(url) {
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
      return await r.arrayBuffer();
    }

    async function load() {
      const statusEl = document.getElementById('status');
      const versionEl = document.getElementById('version');
      const tablesEl = document.getElementById('tables');
      const summaryEl = document.getElementById('summary');

      try {
        const v = await fetchText(VERSION_URL);
        versionEl.textContent = v === '0' ? 'not available yet' : new Date(parseInt(v,10)*1000).toLocaleString();
      } catch (e) {
        versionEl.textContent = 'unknown';
      }

      let SQL;
      try {
        // Load sql.js from CDN (no server changes needed)
        const mod = await window.initSqlJs({ locateFile: f => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${f}` });
        SQL = mod;
      } catch (e) {
        statusEl.innerHTML = `<span class="error">Failed to load sql.js</span>`;
        console.error(e);
        return;
      }

      let dbBytes;
      try {
        dbBytes = new Uint8Array(await fetchArrayBuffer(SNAPSHOT_URL));
      } catch (e) {
        statusEl.innerHTML = `<span class="error">No snapshot available for <b>${MANAGER_ID}</b>. Ask your manager to upload from the app.</span>`;
        console.warn(e);
        return;
      }

      statusEl.innerHTML = `<span class="ok">Snapshot loaded (${(dbBytes.byteLength/1024).toFixed(1)} KB)</span>`;

      const db = new SQL.Database(dbBytes);

      // List tables
      const res = db.exec("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name");
      const tableNames = res.length ? res[0].values.flat() : [];
      tablesEl.innerHTML = tableNames.map(n => `<span class="pill">${n}</span>`).join(' ');

      // Dashboard sections
      try { renderActiveEventSection(db, tableNames); } catch (e) { console.warn(e); }
      try { renderPairingsSection(db, tableNames); } catch (e) { console.warn(e); }
      try { renderBingoSection(db, tableNames); } catch (e) { console.warn(e); }
      try { renderLeagueSection(db, tableNames); } catch (e) { console.warn(e); }

      // Populate generic table browser
      const selector = document.getElementById('tableSelector');
      for (const n of tableNames) {
        const opt = document.createElement('option');
        opt.value = n; opt.textContent = n; selector.appendChild(opt);
      }
      selector.addEventListener('change', () => showTable(db, selector.value));
      if (tableNames.length) showTable(db, tableNames[0]);
    }

    function renderQuery(db, title, sql) {
      let rows = [];
      let columns = [];
      try {
        const r = db.exec(sql);
        if (r.length) {
          columns = r[0].columns;
          rows = r[0].values;
        }
      } catch (e) {
        console.warn('Query failed', e);
      }
      if (!columns.length) return '';
      const head = `<tr>${columns.map(c=>`<th>${escapeHtml(c)}</th>`).join('')}</tr>`;
      const body = rows.map(row => `<tr>${row.map(v => `<td>${escapeHtml(String(v))}</td>`).join('')}</tr>`).join('');
      return `<div class="card"><h3>${title}</h3><div class="table-wrap"><table>${head}${body}</table></div></div>`;
    }

    function showTable(db, name) {
      const out = document.getElementById('tableOut');
      out.innerHTML = renderQuery(db, `Table: ${name}`, `SELECT * FROM '${name}' LIMIT 500`);
    }

    function escapeHtml(s) { return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }

    function getSingle(db, sql) {
      try {
        const r = db.exec(sql);
        if (r.length && r[0].values.length) {
          const cols = r[0].columns;
          const vals = r[0].values[0];
          const obj = {};
          cols.forEach((c, i) => obj[c] = vals[i]);
          return obj;
        }
      } catch (e) { /* noop */ }
      return null;
    }

    function renderActiveEventSection(db, tableNames) {
      const el = document.getElementById('activeEvent');
      if (!tableNames.includes('events')) {
        el.innerHTML = '<p class="muted">No events table.</p>';
        return;
      }
      // Prefer explicit active status, otherwise most recent with current_round>0, otherwise latest
      let ev = getSingle(db, "SELECT id,name,type,rounds,current_round,status,round_start_ts FROM events WHERE status IN ('active','running') ORDER BY id DESC LIMIT 1");
      if (!ev) ev = getSingle(db, "SELECT id,name,type,rounds,current_round,status,round_start_ts FROM events WHERE IFNULL(current_round,0)>0 ORDER BY id DESC LIMIT 1");
      if (!ev) ev = getSingle(db, "SELECT id,name,type,rounds,current_round,status,round_start_ts FROM events ORDER BY id DESC LIMIT 1");
      if (!ev) {
        el.innerHTML = '<p class="muted">No events yet.</p>';
        return;
      }
      const when = ev.round_start_ts ? new Date(parseInt(ev.round_start_ts,10)*1000).toLocaleString() : '—';
      el.innerHTML = `
        <div><b>${escapeHtml(ev.name || 'Event')}</b> <span class="pill">${escapeHtml(ev.type||'')}</span></div>
        <div>Status: <b>${escapeHtml(ev.status||'unknown')}</b></div>
        <div>Round: <b>${ev.current_round ?? 0}</b> / ${ev.rounds ?? '?'}</div>
        <div>Round started: <span class="pill">${when}</span></div>
      `;
      // Cache active id for pairings
      window.__ACTIVE_EVENT_ID__ = ev.id;
      window.__ACTIVE_ROUND__ = ev.current_round ?? 0;
    }

    function renderPairingsSection(db, tableNames) {
      const el = document.getElementById('pairings');
      if (!tableNames.includes('matches')) {
        el.innerHTML = '<p class="muted">No matches table.</p>';
        return;
      }
      const evId = window.__ACTIVE_EVENT_ID__;
      const rnd = window.__ACTIVE_ROUND__;
      if (!evId || !rnd) {
        el.innerHTML = '<p class="muted">No active round.</p>';
        return;
      }
      const sql = `
        SELECT m.round,
               COALESCE(p1.nickname, p1.name, 'BYE') AS p1,
               COALESCE(p2.nickname, p2.name, 'BYE') AS p2,
               m.score_p1 AS s1,
               m.score_p2 AS s2,
               m.bye
        FROM matches m
        LEFT JOIN players p1 ON p1.id = m.player1
        LEFT JOIN players p2 ON p2.id = m.player2
        WHERE m.event_id = ${evId} AND m.round = ${rnd}
        ORDER BY m.id
      `;
      const r = db.exec(sql);
      if (!r.length || !r[0].values.length) {
        el.innerHTML = '<p class="muted">No pairings for current round.</p>';
        return;
      }
      const rows = r[0].values.map(v => [v[1], v[3] != null ? v[3] : '', '-', v[2], v[4] != null ? v[4] : '']);
      const head = `<tr><th>Player 1</th><th>Score</th><th></th><th>Player 2</th><th>Score</th></tr>`;
      const body = rows.map(row => `<tr>${row.map(x => `<td>${escapeHtml(String(x))}</td>`).join('')}</tr>`).join('');
      el.innerHTML = `<table>${head}${body}</table>`;
    }

    function renderBingoSection(db, tableNames) {
      const el = document.getElementById('bingo');
      if (!(tableNames.includes('bingo_players') && tableNames.includes('bingo_meta'))) {
        el.innerHTML = '<p class="muted">Bingo not configured.</p>';
        return;
      }
      const meta = getSingle(db, 'SELECT row0,row1,row2,col0,col1,col2,diag0,diag1,full FROM bingo_meta WHERE id=1');
      let metaBadges = '';
      if (meta) {
        const labels = [];
        if (meta.row0) labels.push('Row 1');
        if (meta.row1) labels.push('Row 2');
        if (meta.row2) labels.push('Row 3');
        if (meta.col0) labels.push('Col 1');
        if (meta.col1) labels.push('Col 2');
        if (meta.col2) labels.push('Col 3');
        if (meta.diag0) labels.push('Diag ↘');
        if (meta.diag1) labels.push('Diag ↙');
        if (meta.full) labels.push('Full Bingo');
        if (labels.length) metaBadges = labels.map(x=>`<span class="pill">${x}</span>`).join(' ');
      }
      const rs = db.exec(`
        SELECT COALESCE(p.nickname,p.name,'Player') AS player,
               (bp.c0+bp.c1+bp.c2+bp.c3+bp.c4+bp.c5+bp.c6+bp.c7+bp.c8) AS marks
        FROM bingo_players bp
        LEFT JOIN players p ON p.id = bp.player_id
        ORDER BY marks DESC, player ASC
      `);
      if (!rs.length || !rs[0].values.length) {
        el.innerHTML = '<p class="muted">No bingo progress yet.</p>';
        return;
      }
      const head = `<tr><th>Player</th><th>Marks</th></tr>`;
      const body = rs[0].values.map(v => `<tr><td>${escapeHtml(String(v[0]))}</td><td>${v[1]}</td></tr>`).join('');
      el.innerHTML = `${metaBadges ? `<div style="margin-bottom:6px">${metaBadges}</div>`:''}<table>${head}${body}</table>`;
    }

    function renderLeagueSection(db, tableNames) {
      const el = document.getElementById('league');
      if (!tableNames.includes('leagues')) {
        el.innerHTML = '<p class="muted">No leagues defined.</p>';
        return;
      }
      const lg = getSingle(db, 'SELECT id,name,start_ts,end_ts FROM leagues ORDER BY IFNULL(end_ts, 32503680000) DESC, start_ts DESC LIMIT 1');
      if (!lg) { el.innerHTML = '<p class="muted">No leagues found.</p>'; return; }
      // Aggregate wins across all matches since league start (events proxy via created_at)
      // Fallback: if events table exists, restrict to events created after league start
      let where = '';
      if (tableNames.includes('events')) {
        where = ` AND m.event_id IN (SELECT id FROM events WHERE IFNULL(strftime('%s', created_at), 0) >= ${lg.start_ts || 0} ${lg.end_ts ? `AND IFNULL(strftime('%s', created_at),0) <= ${lg.end_ts}`:''})`;
      }
      const sql = `
        WITH wins AS (
          SELECT player1 AS pid, SUM(CASE WHEN IFNULL(score_p1,0) > IFNULL(score_p2,0) THEN 1 ELSE 0 END) AS w,
                 SUM(CASE WHEN IFNULL(score_p1,0) < IFNULL(score_p2,0) THEN 1 ELSE 0 END) AS l
          FROM matches m WHERE IFNULL(bye,0)=0 ${where}
          UNION ALL
          SELECT player2 AS pid, SUM(CASE WHEN IFNULL(score_p2,0) > IFNULL(score_p1,0) THEN 1 ELSE 0 END) AS w,
                 SUM(CASE WHEN IFNULL(score_p2,0) < IFNULL(score_p1,0) THEN 1 ELSE 0 END) AS l
          FROM matches m WHERE IFNULL(bye,0)=0 ${where}
        )
        SELECT COALESCE(p.nickname,p.name,'Player') AS player, SUM(w) AS wins, SUM(l) AS losses
        FROM wins
        LEFT JOIN players p ON p.id = pid
        GROUP BY pid
        HAVING (wins + losses) > 0
        ORDER BY wins DESC, losses ASC, player ASC
        LIMIT 50
      `;
      const r = db.exec(sql);
      const title = `${escapeHtml(lg.name || 'League')} ${lg.start_ts ? '('+new Date(lg.start_ts*1000).toLocaleDateString()+ (lg.end_ts? ' – '+new Date(lg.end_ts*1000).toLocaleDateString():'') +')' : ''}`;
      if (!r.length || !r[0].values.length) { el.innerHTML = `<div class="muted">No match data for ${title}.</div>`; return; }
      const head = `<tr><th>Player</th><th>Wins</th><th>Losses</th></tr>`;
      const body = r[0].values.map(v => `<tr><td>${escapeHtml(String(v[0]))}</td><td>${v[1]}</td><td>${v[2]}</td></tr>`).join('');
      el.innerHTML = `<div style="margin-bottom:6px"><b>${title}</b></div><table>${head}${body}</table>`;
    }

    window.addEventListener('DOMContentLoaded', load);
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.js" referrerpolicy="no-referrer"></script>
</head>
<body>
  <header>
    <h2 style="margin:0">Draft Buddy – Public View <small class="muted">(<span id="managerId">__MANAGER_ID__</span>)</small></h2>
  </header>
  <main>
    <div class="row">
      <div class="card">
        <b>Snapshot version:</b> <span id="version" class="pill">checking…</span>
      </div>
    </div>

    <div class="card">
      <div id="status" class="muted">Loading…</div>
      <div><b>Tables:</b> <span id="tables"></span></div>
    </div>

    <div id="summary"></div>

    <div class="card" id="activeEventCard">
      <h3>Active Event</h3>
      <div id="activeEvent"></div>
    </div>

    <div class="card" id="pairingsCard">
      <h3>Current Round Pairings</h3>
      <div id="pairings"></div>
    </div>

    <div class="card" id="bingoCard">
      <h3>Bingo Progress</h3>
      <div id="bingo"></div>
    </div>

    <div class="card" id="leagueCard">
      <h3>League Standings</h3>
      <div id="league"></div>
    </div>

    <div class="card">
      <h3>Table Browser</h3>
      <label>Select a table: <select id="tableSelector"></select></label>
      <div id="tableOut" style="margin-top:8px"></div>
      <p class="muted">Note: This view is read‑only and updates when the manager uploads a new snapshot from the app.</p>
    </div>
  </main>
</body>
</html>
